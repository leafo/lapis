local db = require("lapis.db.postgres")
local select, pairs, unpack, type
do
  local _obj_0 = _G
  select, pairs, unpack, type, select = _obj_0.select, _obj_0.pairs, _obj_0.unpack, _obj_0.type, _obj_0.select
end
local insert
insert = table.insert
local BaseModel, Enum, enum
do
  local _obj_0 = require("lapis.db.base_model")
  BaseModel, Enum, enum = _obj_0.BaseModel, _obj_0.Enum, _obj_0.enum
end
local preload
preload = require("lapis.db.model.relations").preload
local Model
do
  local _class_0
  local _parent_0 = BaseModel
  local _base_0 = {
    update = function(self, first, ...)
      local cond = self:_primary_cond()
      local columns
      if type(first) == "table" then
        do
          local _accum_0 = { }
          local _len_0 = 1
          for k, v in pairs(first) do
            if type(k) == "number" then
              _accum_0[_len_0] = v
            else
              self[k] = v
              _accum_0[_len_0] = k
            end
            _len_0 = _len_0 + 1
          end
          columns = _accum_0
        end
      else
        columns = {
          first,
          ...
        }
      end
      if next(columns) == nil then
        return nil, "nothing to update"
      end
      if self.__class.constraints then
        for _, column in pairs(columns) do
          do
            local err = self.__class:_check_constraint(column, self[column], self)
            if err then
              return nil, err
            end
          end
        end
      end
      local values
      do
        local _tbl_0 = { }
        for _index_0 = 1, #columns do
          local col = columns[_index_0]
          _tbl_0[col] = self[col]
        end
        values = _tbl_0
      end
      local nargs = select("#", ...)
      local last = nargs > 0 and select(nargs, ...)
      local opts
      if type(last) == "table" then
        opts = last
      end
      if self.__class.timestamp and not (opts and opts.timestamp == false) then
        local time = self.__class.db.format_date()
        values.updated_at = values.updated_at or time
      end
      local returning
      for k, v in pairs(values) do
        if v == db.NULL then
          self[k] = nil
        elseif db.is_raw(v) then
          returning = returning or { }
          table.insert(returning, k)
        end
      end
      if returning then
        do
          local res = db.update(self.__class:table_name(), values, cond, unpack(returning))
          do
            local update = unpack(res)
            if update then
              for _index_0 = 1, #returning do
                local k = returning[_index_0]
                self[k] = update[k]
              end
            end
          end
          return res
        end
      else
        return db.update(self.__class:table_name(), values, cond)
      end
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__base)
  _class_0 = setmetatable({
    __init = function(self, ...)
      return _class_0.__parent.__init(self, ...)
    end,
    __base = _base_0,
    __name = "Model",
    __parent = _parent_0
  }, {
    __index = function(cls, name)
      local val = rawget(_base_0, name)
      if val == nil then
        local parent = rawget(cls, "__parent")
        if parent then
          return parent[name]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  _base_0.__class = _class_0
  local self = _class_0
  self.db = db
  self.create = function(self, values, opts)
    if values == nil then
      values = { }
    end
    if self.constraints then
      for key in pairs(self.constraints) do
        do
          local err = self:_check_constraint(key, values and values[key], values)
          if err then
            return nil, err
          end
        end
      end
    end
    if self.timestamp then
      local time = self.db.format_date()
      values.created_at = values.created_at or time
      values.updated_at = values.updated_at or time
    end
    local returning, return_all, nil_fields
    if opts and opts.returning then
      if opts.returning == "*" then
        return_all = true
        returning = {
          db.raw("*")
        }
      else
        returning = {
          self:primary_keys()
        }
        local _list_0 = opts.returning
        for _index_0 = 1, #_list_0 do
          local field = _list_0[_index_0]
          table.insert(returning, field)
        end
      end
    end
    for k, v in pairs(values) do
      local _continue_0 = false
      repeat
        if v == db.NULL then
          nil_fields = nil_fields or { }
          nil_fields[k] = true
          _continue_0 = true
          break
        elseif db.is_raw(v) then
          returning = returning or {
            self:primary_keys()
          }
          table.insert(returning, k)
        end
        _continue_0 = true
      until true
      if not _continue_0 then
        break
      end
    end
    local res
    if returning then
      res = db.insert(self:table_name(), values, unpack(returning))
    else
      res = db.insert(self:table_name(), values, self:primary_keys())
    end
    if res then
      if returning and not return_all then
        for _index_0 = 1, #returning do
          local k = returning[_index_0]
          values[k] = res[1][k]
        end
      end
      for k, v in pairs(res[1]) do
        values[k] = v
      end
      if nil_fields then
        for k in pairs(nil_fields) do
          values[k] = nil
        end
      end
      return self:load(values)
    else
      return nil, "Failed to create " .. tostring(self.__name)
    end
  end
  if _parent_0.__inherited then
    _parent_0.__inherited(_parent_0, _class_0)
  end
  Model = _class_0
end
return {
  Model = Model,
  Enum = Enum,
  enum = enum,
  preload = preload
}
